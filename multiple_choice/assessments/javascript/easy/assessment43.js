// assessment43.js - AUTO-GENERATED topics and assessmentId
const metadata = {
    "title": "Unit Testing Basics for Beginners",
    "description": "Fundamental concepts of unit testing, test assertions, and testing methodology for JavaScript developers starting with testing.",
    "difficulty": "easy",
    "domain": "javascript",
    "timeLimit": 30,
    "questionCount": 30,
    "topics": [
        "Testing concepts",
        "Test assertions",
        "Testing benefits",
        "Test structure",
        "Testing principles",
        "Test types",
        "Testing workflow"
    ],
    "topicLinks": [
        {
            "topicName": "Testing concepts",
            "refLink": "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Introduction"
        },
        {
            "topicName": "Test assertions",
            "refLink": "https://developer.mozilla.org/en-US/docs/Web/API/Console/assert"
        },
        {
            "topicName": "Testing benefits",
            "refLink": "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Testing_strategies"
        },
        {
            "topicName": "Test structure",
            "refLink": "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Test_runner"
        },
        {
            "topicName": "Testing principles",
            "refLink": "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Introduction"
        },
        {
            "topicName": "Test types",
            "refLink": "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Automated_testing"
        },
        {
            "topicName": "Testing workflow",
            "refLink": "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Testing_strategies"
        }
    ],
    "assessmentId": 43,
    "assessmentUniqueId": 1762788896345,
    "testType": "multiple-choice"
};

const questions = [
    {
        "id": 1,
        "question": "What is a unit in unit testing?",
        "options": {
            "A": "A single function, method, or small piece of code",
            "B": "An entire application module",
            "C": "A complete user interface",
            "D": "A database table"
        },
        "correct": "A",
        "explanation": "A unit typically refers to the smallest testable part of an application, such as a single function, method, or class. Unit testing focuses on verifying these small pieces work correctly in isolation.",
        "topic": {
            "topics": ["Testing concepts"]
        }
    },
    {
        "id": 2,
        "question": "What is the main goal of writing test assertions?",
        "options": {
            "A": "To verify code behaves as expected",
            "B": "To make code run faster",
            "C": "To reduce code complexity",
            "D": "To generate documentation"
        },
        "correct": "A",
        "explanation": "Assertions are statements that check if certain conditions are true during test execution. They verify that the code produces the expected results for given inputs.",
        "topic": {
            "topics": ["Test assertions"]
        }
    },
    {
        "id": 3,
        "question": "What is the purpose of automated testing tools?",
        "options": {
            "A": "To run tests automatically and report results",
            "B": "To write code automatically",
            "C": "To fix bugs automatically",
            "D": "To design user interfaces"
        },
        "correct": "A",
        "explanation": "Automated testing tools execute tests without manual intervention, run them repeatedly, and provide reports on which tests passed or failed. This saves time and ensures consistent testing.",
        "topic": {
            "topics": ["Testing workflow"]
        }
    },
    {
        "id": 4,
        "question": "What does a passing test indicate?",
        "options": {
            "A": "The code meets the test requirements",
            "B": "The code is completely bug-free",
            "C": "The code is optimized for performance",
            "D": "The code is ready for production"
        },
        "correct": "A",
        "explanation": "A passing test means the code currently meets the specific requirements defined in that test. It doesn't guarantee the code is perfect, but it confirms the tested behavior works as expected.",
        "topic": {
            "topics": ["Testing concepts"]
        }
    },
    {
        "id": 5,
        "question": "Why is isolation important in unit testing?",
        "options": {
            "A": "To test one thing at a time without external dependencies",
            "B": "To make tests run in parallel",
            "C": "To reduce test file size",
            "D": "To use less memory"
        },
        "correct": "A",
        "explanation": "Isolation ensures that unit tests focus on testing one specific piece of functionality without interference from external dependencies. This makes tests more reliable and easier to debug when they fail.",
        "topic": {
            "topics": ["Testing principles"]
        }
    },
    {
        "id": 6,
        "question": "What is a test runner?",
        "options": {
            "A": "A tool that executes tests and reports results",
            "B": "A person who manually tests software",
            "C": "A type of assertion method",
            "D": "A performance monitoring tool"
        },
        "correct": "A",
        "explanation": "A test runner is software that automatically finds test files, executes the tests, and reports which tests passed or failed. Test runners work with any testing framework to automate the testing process.",
        "topic": {
            "topics": ["Testing workflow"]
        }
    },
    {
        "id": 7,
        "question": "What should you test in a function that adds two numbers?",
        "options": {
            "A": "Normal cases, edge cases, and error cases",
            "B": "Only positive numbers",
            "C": "Only whole numbers",
            "D": "Only the most common scenario"
        },
        "correct": "A",
        "explanation": "Good tests cover various scenarios: normal cases (2+3=5), edge cases (0+0=0, large numbers), and error cases (invalid inputs). This ensures the function behaves correctly in different situations.",
        "topic": {
            "topics": ["Testing principles"]
        }
    },
    {
        "id": 8,
        "question": "What is the purpose of test descriptions?",
        "options": {
            "A": "To clearly state what behavior is being tested",
            "B": "To make tests look more professional",
            "C": "To satisfy the test framework requirements",
            "D": "To add comments to the code"
        },
        "correct": "A",
        "explanation": "Clear test descriptions help developers understand what specific behavior is being verified. When tests fail, good descriptions make it easier to identify what's broken and why.",
        "topic": {
            "topics": ["Testing principles"]
        }
    },
    {
        "id": 9,
        "question": "What is regression testing?",
        "options": {
            "A": "Testing that new changes don't break existing features",
            "B": "Testing only the oldest parts of the codebase",
            "C": "Testing with outdated browsers",
            "D": "Testing performance regression only"
        },
        "correct": "A",
        "explanation": "Regression testing ensures that previously working functionality continues to work after new changes, updates, or bug fixes are made to the codebase.",
        "topic": {
            "topics": ["Testing benefits"]
        }
    },
    {
        "id": 10,
        "question": "What does a test suite contain?",
        "options": {
            "A": "A collection of related test cases",
            "B": "A single test assertion",
            "C": "Testing documentation",
            "D": "Performance benchmarks"
        },
        "correct": "A",
        "explanation": "A test suite is a collection of test cases that are grouped together, usually testing related functionality or a specific module of the application.",
        "topic": {
            "topics": ["Test structure"]
        }
    },
    {
        "id": 11,
        "question": "Why are automated tests valuable?",
        "options": {
            "A": "They can run quickly and repeatedly without manual effort",
            "B": "They eliminate all bugs automatically",
            "C": "They write the code for you",
            "D": "They never need to be updated"
        },
        "correct": "A",
        "explanation": "Automated tests save time and effort by running frequently during development, catching issues early, and ensuring code quality without manual testing for every change.",
        "topic": {
            "topics": ["Testing benefits"]
        }
    },
    {
        "id": 12,
        "question": "What is a positive test case?",
        "options": {
            "A": "Testing with valid inputs that should work correctly",
            "B": "A test that always passes",
            "C": "Testing only when you feel positive",
            "D": "Testing with positive numbers only"
        },
        "correct": "A",
        "explanation": "Positive test cases verify that the system works correctly with valid, expected inputs and normal usage scenarios.",
        "topic": {
            "topics": ["Test types"]
        }
    },
    {
        "id": 13,
        "question": "What is a negative test case?",
        "options": {
            "A": "Testing with invalid inputs and error conditions",
            "B": "A test that always fails",
            "C": "Testing with negative numbers",
            "D": "A poorly written test"
        },
        "correct": "A",
        "explanation": "Negative test cases verify that the system properly handles invalid inputs, edge cases, and error conditions without crashing or behaving unexpectedly.",
        "topic": {
            "topics": ["Test types"]
        }
    },
    {
        "id": 14,
        "question": "What does 'test coverage' measure?",
        "options": {
            "A": "How much of the code is executed by tests",
            "B": "The number of tests written",
            "C": "How many developers reviewed the tests",
            "D": "The percentage of bugs found"
        },
        "correct": "A",
        "explanation": "Test coverage is a metric that measures what percentage of your source code is executed when your tests run, helping identify untested areas of the codebase.",
        "topic": {
            "topics": ["Testing concepts"]
        }
    },
    {
        "id": 15,
        "question": "What is the first step in the Arrange-Act-Assert pattern?",
        "options": {
            "A": "Set up test data and preconditions",
            "B": "Call the function being tested",
            "C": "Check the results",
            "D": "Clean up after the test"
        },
        "correct": "A",
        "explanation": "In Arrange-Act-Assert, the 'Arrange' step involves setting up all necessary test data, mock objects, and preconditions before executing the code being tested.",
        "topic": {
            "topics": ["Test structure"]
        }
    },
    {
        "id": 16,
        "question": "What should you do when you find a bug?",
        "options": {
            "A": "Write a test that reproduces the bug, then fix it",
            "B": "Immediately fix the code without testing",
            "C": "Ignore it if it's minor",
            "D": "Only fix it before release"
        },
        "correct": "A",
        "explanation": "When you find a bug, first write a test that demonstrates the faulty behavior. Then fix the code so the test passes. This ensures the bug doesn't reappear (regression) and documents the expected behavior.",
        "topic": {
            "topics": ["Testing workflow"]
        }
    },
    {
        "id": 17,
        "question": "What is the benefit of fast-running tests?",
        "options": {
            "A": "They provide quick feedback during development",
            "B": "They find more complex bugs",
            "C": "They're easier to write",
            "D": "They use less disk space"
        },
        "correct": "A",
        "explanation": "Fast tests can be run frequently during development, providing immediate feedback about whether recent changes broke anything. This encourages developers to run tests often.",
        "topic": {
            "topics": ["Testing benefits"]
        }
    },
    {
        "id": 18,
        "question": "What is a mock object used for in testing?",
        "options": {
            "A": "To simulate real dependencies during testing",
            "B": "To make tests look more realistic",
            "C": "To generate random test data",
            "D": "To style test output"
        },
        "correct": "A",
        "explanation": "Mock objects simulate the behavior of real dependencies (like databases, APIs, or other services) so you can test units in isolation without relying on external systems.",
        "topic": {
            "topics": ["Testing concepts"]
        }
    },
    {
        "id": 19,
        "question": "What does TDD stand for in software development?",
        "options": {
            "A": "Test-Driven Development",
            "B": "Test Design Documentation",
            "C": "Total Development Duration",
            "D": "Technical Design Document"
        },
        "explanation": "Test-Driven Development (TDD) is a software development approach where you write tests before writing the implementation code, following the red-green-refactor cycle.",
        "correct": "A",
        "topic": {
            "topics": ["Testing workflow"]
        }
    },
    {
        "id": 20,
        "question": "Why should tests be independent from each other?",
        "options": {
            "A": "So one test failure doesn't affect other tests",
            "B": "To make tests run in alphabetical order",
            "C": "Because they test different functions",
            "D": "To reduce test file size"
        },
        "correct": "A",
        "explanation": "Independent tests don't rely on the state or results of other tests. This ensures that test failures are isolated and tests can run in any order without affecting each other.",
        "topic": {
            "topics": ["Testing principles"]
        }
    },
    {
        "id": 21,
        "question": "What is integration testing?",
        "options": {
            "A": "Testing how multiple units work together",
            "B": "Testing individual functions in isolation",
            "C": "Testing the user interface only",
            "D": "Testing with integrated development environments"
        },
        "correct": "A",
        "explanation": "Integration testing verifies that different units or components work correctly when combined together, testing the interactions between them rather than individual units in isolation.",
        "topic": {
            "topics": ["Test types"]
        }
    },
    {
        "id": 22,
        "question": "What is the main advantage of having many small tests?",
        "options": {
            "A": "Easier to pinpoint exactly what's broken",
            "B": "They run faster as a group",
            "C": "They're easier to write",
            "D": "They find more complex bugs"
        },
        "correct": "A",
        "explanation": "Small, focused tests each verify one specific behavior. When a test fails, it's immediately clear what exact functionality is broken, making debugging much easier.",
        "topic": {
            "topics": ["Testing principles"]
        }
    },
    {
        "id": 23,
        "question": "What do testing frameworks typically provide?",
        "options": {
            "A": "Assertion methods, test runners, and utilities",
            "B": "Code editors and debuggers",
            "C": "Performance optimization tools",
            "D": "User interface components"
        },
        "correct": "A",
        "explanation": "Testing frameworks provide built-in assertion methods to check conditions, test runners to execute tests, and various utilities for organizing tests, mocking dependencies, and reporting results in a standardized way.",
        "topic": {
            "topics": ["Testing workflow"]
        }
    },
    {
        "id": 24,
        "question": "What is the purpose of test data?",
        "options": {
            "A": "To provide inputs for the code being tested",
            "B": "To fill up test databases",
            "C": "To make tests look more realistic",
            "D": "To generate random values"
        },
        "correct": "A",
        "explanation": "Test data consists of the specific inputs and expected outputs used to verify that code behaves correctly under various conditions and scenarios.",
        "topic": {
            "topics": ["Test structure"]
        }
    },
    {
        "id": 25,
        "question": "Why is testing important for team development?",
        "options": {
            "A": "It helps prevent breaking code that others depend on",
            "B": "It makes code reviews unnecessary",
            "C": "It eliminates the need for documentation",
            "D": "It reduces the number of meetings"
        },
        "correct": "A",
        "explanation": "Tests provide confidence that changes won't break functionality that other team members rely on. This is especially important in large teams where multiple people work on different parts of the same codebase.",
        "topic": {
            "topics": ["Testing benefits"]
        }
    },
    {
        "id": 26,
        "question": "What should you verify in a test for a sorting function?",
        "options": {
            "A": "That it correctly sorts various input arrays",
            "B": "That it uses the most efficient algorithm",
            "C": "That it has the fewest lines of code",
            "D": "That it doesn't call other functions"
        },
        "correct": "A",
        "explanation": "Tests for a sorting function should verify it produces correctly sorted output for different inputs: already sorted arrays, reverse-sorted arrays, arrays with duplicates, empty arrays, etc.",
        "topic": {
            "topics": ["Test assertions"]
        }
    },
    {
        "id": 27,
        "question": "What is the role of assertions in testing?",
        "options": {
            "A": "To check if actual results match expected results",
            "B": "To log information to the console",
            "C": "To stop test execution early",
            "D": "To generate test reports"
        },
        "correct": "A",
        "explanation": "Assertions are the core of testing - they compare the actual output of code with the expected output and fail the test if they don't match.",
        "topic": {
            "topics": ["Test assertions"]
        }
    },
    {
        "id": 28,
        "question": "What does a test typically verify about a function?",
        "options": {
            "A": "Its output for given inputs matches expectations",
            "B": "Its internal implementation details",
            "C": "Its variable names are meaningful",
            "D": "Its code style follows conventions"
        },
        "correct": "A",
        "explanation": "Good tests focus on verifying the behavior and output of functions (what they do) rather than their internal implementation (how they do it). This allows implementation to change without breaking tests, as long as behavior remains correct.",
        "topic": {
            "topics": ["Testing principles"]
        }
    },
    {
        "id": 29,
        "question": "What is the benefit of running tests automatically?",
        "options": {
            "A": "Early detection of problems in the development process",
            "B": "Complete elimination of all bugs",
            "C": "Automatic code optimization",
            "D": "Reduction in code size"
        },
        "correct": "A",
        "explanation": "Automated tests run as part of the development workflow to catch issues early, before they reach production, saving time and reducing the cost of fixing bugs.",
        "topic": {
            "topics": ["Testing benefits"]
        }
    },
    {
        "id": 30,
        "question": "What is the first thing to consider when writing a test?",
        "options": {
            "A": "What specific behavior you want to verify",
            "B": "Which testing framework to use",
            "C": "How to name the test file",
            "D": "What assertions are available"
        },
        "explanation": "Before writing any test code, you should clearly understand what specific behavior or requirement you're trying to verify. This ensures the test has a clear purpose and will provide meaningful feedback.",
        "correct": "A",
        "topic": {
            "topics": ["Testing workflow"]
        }
    }
];

module.exports = { metadata, questions };